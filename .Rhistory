s2.trp <- treeresponse(sforest)
s2b$PredFOREST <- sapply(s2.trp, FUN = function(v)return(v[2]))
s2b$s_los_bin <- (s2b$s_los=="s-los") + 0
somers2(s2b$PredFOREST, s2b$s_los_bin)
# png("wegens_tree.png", width = 7.5, height = 5, un = "in", res = 300)
plot(stree)
d <- readxl::read_xlsx("/Users/stefanhartmann/sciebo/Projekte/wanderndes_Kasusmorphem/wegens/wegen_postnom_DECOW16A_NANO_filtered.xlsx")
readr::write_csv(d, "wegens/wegen_postnom_DECOW16A_NANO_filtered.csv")
# CRAN-Pakete installieren
sapply(c("data.table", "tidyverse", "devtools", "party", "Hmisc", "rms", "RColorBrewer", "readxl"), function(x)
if(!is.element(x, installed.packages())) install.packages(x, dependencies = T))
# Nom-CRAN-Paket installieren (falls noch nicht installiert)
if(!is.element("wizard", installed.packages())) {
devtools::install_github("hartmast/wizard")
}
# Pakete laden
library(tidyverse)
library(data.table)
library(wizard)
library(party)
library(Hmisc)
library(rms)
library(RColorBrewer)
library(readxl)
# Funktion, um schnell Barplots zu erstellen
qbarplot2 <- function(df, ..., color = c("Blues", F), angle = 0) {
if(missing(color)) { color = "Blues"  }
p <- qbarplot(df, cex = 5, ...) + theme_bw() +
theme(axis.text = element_text(size = 18)) +
theme(axis.title = element_text(size = 18)) +
theme(strip.text = element_text(size = 18)) +
theme(legend.text = element_text(size = 18)) +
theme(legend.title = element_text(size = 18, face = "bold")) +
theme(text = element_text(size = 18))
if(angle!=0) {
p <- p + theme(axis.text.y = element_text(size = 18)) +
theme(axis.text.x = element_text(angle = angle, size = 18,hjust = .9))
} else {
if(angle!=0) {
p <- p + theme(axis.text = element_text(size = 18))
}
}
if(color == "Blues") {
p <- p + scale_fill_brewer("Blues")
}
return(p)
}
# Daten einlesen
ws <- read_csv("wegens/wegens_DECOW16BX_anno.csv")
ws <- mutate(ws, cxn = "wegens")
w0 <- read_csv("wegens/wegen_sample_DECOW16BX_anno.csv")
w0 <- mutate(w0, cxn = "wegen")
uws <- read_csv("willens/um_willens_DECOW16B.csv")
uws <- mutate(uws, cxn = "willens")
uw0 <- read_csv("willens/um_willen_DECOW16B_sample.csv")
uw0 <- mutate(uw0, cxn = "willen")
colnames(uws)
colnames(uw0)
colnames(ws) == colnames(w0)
# Nacherhebung postnominales wegen:
w0p <- read_csv("wegens/wegen_postnom_DECOW16A_NANO_filtered.csv")
w0p <- mutate(w0, cxn = "wegen")
# um ... willens:
uws <- read_csv("willens/um_willens_DECOW16B.csv")
# um ... willens:
uws <- read_csv("willens/um_willens_DECOW16B.csv")
uws <- mutate(uws, cxn = "willens")
# um ... willen ohne s:
uw0 <- read_csv("willens/um_willen_DECOW16B_sample.csv")
uw0 <- mutate(uw0, cxn = "willen")
# relevante Spalten finden
intersect(colnames(w0), colnames(w0p))
colnames(w0p)
# Nacherhebung postnominales wegen:
w0p <- read_csv("wegens/wegen_postnom_DECOW16A_NANO_filtered.csv")
w0p <- mutate(w0p, cxn = "wegen")
# relevante Spalten finden
intersect(colnames(w0), colnames(w0p))
View(uw0)
colnames(uw0)
read_xlsx("/Users/stefanhartmann/sciebo/Projekte/wanderndes_Kasusmorphem/wegens/wegen_postnom_DECOW16A_NANO_filtered.xlsx") %>% write_csv("wegens/wegen_postnom_DECOW16A_NANO_filtered.csv")
# Nacherhebung postnominales wegen:
w0p <- read_csv("wegens/wegen_postnom_DECOW16A_NANO_filtered.csv")
w0p <- mutate(w0p, cxn = "wegen")
View(w0p)
# relevante Spalten finden
intersect(colnames(w0), colnames(w0p))
# relevante Spalten finden
mycols <- intersect(colnames(w0), colnames(w0p))
mycols
which(colnames(w0) %in% mycols)
select(ws, mycols)
select(ws, all_of(mycols))
mutate(ws, select(ws, all_of(mycols)), cxn = "wegens")
mutate(select(ws, all_of(mycols)), cxn = "wegens")
mutate(select(w0, all_of(mysols)), cxn = "wegen")
mutate(select(w0, all_of(mycols)), cxn = "wegen")
# relevante Spalten finden
mycols <- intersect(colnames(w0), colnames(ws), colnames(w0p))
# relevante Spalten finden
mycols <- intersect(colnames(w0), colnames(w0p))
mutate(select(w0p, all_of(mycols)), cxn = "wegen")
# Spalte Position hinzufügen
w0p$position <- "postnom"
# relevante Spalten finden
mycols <- intersect(colnames(w0), colnames(w0p))
mutate(select(ws, all_of(mycols)), cxn = "wegens")
mutate(select(w0, all_of(mycols)), cxn = "wegen")
mutate(select(w0p, all_of(mycols)), cxn = "wegen")
# zusammenfügen
rbind(mutate(select(ws, all_of(mycols)), cxn = "wegens"),
mutate(select(w0, all_of(mycols)), cxn = "wegen"),
mutate(select(w0p, all_of(mycols)), cxn = "wegen"))
# zusammenfügen
w <- rbind(mutate(select(ws, all_of(mycols)), cxn = "wegens"),
mutate(select(w0, all_of(mycols)), cxn = "wegen"),
mutate(select(w0p, all_of(mycols)), cxn = "wegen"))
# nur true positives behalten
w$keep
# nur true positives behalten
w$keep
# nur true positives behalten
filter(w, keep == "y")
# nur true positives behalten
w <- filter(w, keep == "y")
w
# Spalte Position hinzufügen
w0p$position <- "post"
# um ... willens:
uws <- read_csv("willens/um_willens_DECOW16B.csv")
# Daten einlesen
# wegens:
ws <- read_csv("wegens/wegens_DECOW16BX_anno.csv")
ws <- mutate(ws, cxn = "wegens")
# wegen ohne s:
w0 <- read_csv("wegens/wegen_sample_DECOW16BX_anno.csv")
w0 <- mutate(w0, cxn = "wegen")
# Nacherhebung postnominales wegen:
w0p <- read_csv("wegens/wegen_postnom_DECOW16A_NANO_filtered.csv")
w0p <- mutate(w0p, cxn = "wegen")
# Spalte Position hinzufügen
w0p$position <- "post"
# um ... willens:
uws <- read_csv("willens/um_willens_DECOW16B.csv")
uws <- mutate(uws, cxn = "willens")
# um ... willen ohne s:
uw0 <- read_csv("willens/um_willen_DECOW16B_sample.csv")
uw0 <- mutate(uw0, cxn = "willen")
# DATA WRANGLING - wegen(s)
# relevante Spalten finden
mycols <- intersect(colnames(w0), colnames(w0p))
# zusammenfügen
w <- rbind(mutate(select(ws, all_of(mycols)), cxn = "wegens"),
mutate(select(w0, all_of(mycols)), cxn = "wegen"),
mutate(select(w0p, all_of(mycols)), cxn = "wegen"))
# nur true positives behalten
w <- filter(w, keep == "y")
# DATA WRANGLING - um ... willen(s):
w
# DATA WRANGLING - um ... willen(s):
rbind(uw, uw0)
# DATA WRANGLING - um ... willen(s):
rbind(uw, uw0)
# DATA WRANGLING - um ... willen(s):
rbind(uws, uw0)
# DATA WRANGLING - um ... willen(s):
uw <- rbind(uws, uw0)
# Duplikate entfernen
select(w, Left, Key, Right)
# Duplikate entfernen
select(w, Left, Key, Right) %>% duplicated
# Duplikate entfernen
select(w, Left, Key, Right) %>% duplicated %>% any
# Duplikate entfernen
which(duplicated(select(w, Left, Key, Right)))
# Duplikate entfernen
w[-which(duplicated(select(w, Left, Key, Right))),]
# Duplikate entfernen
w <- w[-which(duplicated(select(w, Left, Key, Right))),]
library(patchwork)
# nur postnominales wegen(s)
filter(w, position == "post")
# nur postnominales wegen(s)
wp <- filter(w, position == "post")
# CRAN-Pakete installieren
sapply(c("data.table", "tidyverse", "devtools", "party", "Hmisc", "rms", "RColorBrewer", "readxl", "patchwork"), function(x)
if(!is.element(x, installed.packages())) install.packages(x, dependencies = T))
# Nom-CRAN-Paket installieren (falls noch nicht installiert)
if(!is.element("wizard", installed.packages())) {
devtools::install_github("hartmast/wizard")
}
# Pakete laden
library(tidyverse)
library(data.table)
library(wizard)
library(party)
library(Hmisc)
library(rms)
library(RColorBrewer)
library(readxl)
library(patchwork)
# Funktion, um schnell Barplots zu erstellen
qbarplot2 <- function(df, ..., color = c("Blues", F), angle = 0) {
if(missing(color)) { color = "Blues"  }
p <- qbarplot(df, cex = 5, ...) + theme_bw() +
theme(axis.text = element_text(size = 18)) +
theme(axis.title = element_text(size = 18)) +
theme(strip.text = element_text(size = 18)) +
theme(legend.text = element_text(size = 18)) +
theme(legend.title = element_text(size = 18, face = "bold")) +
theme(text = element_text(size = 18))
if(angle!=0) {
p <- p + theme(axis.text.y = element_text(size = 18)) +
theme(axis.text.x = element_text(angle = angle, size = 18,hjust = .9))
} else {
if(angle!=0) {
p <- p + theme(axis.text = element_text(size = 18))
}
}
if(color == "Blues") {
p <- p + scale_fill_brewer("Blues")
}
return(p)
}
# wegens:
ws <- read_csv("wegens/wegens_DECOW16BX_anno.csv")
ws <- mutate(ws, cxn = "wegens")
# wegen ohne s:
w0 <- read_csv("wegens/wegen_sample_DECOW16BX_anno.csv")
w0 <- mutate(w0, cxn = "wegen")
# Nacherhebung postnominales wegen:
w0p <- read_csv("wegens/wegen_postnom_DECOW16A_NANO_filtered.csv")
w0p <- mutate(w0p, cxn = "wegen")
# Spalte Position hinzufügen
w0p$position <- "post"
# um ... willens:
uws <- read_csv("willens/um_willens_DECOW16B.csv")
uws <- mutate(uws, cxn = "willens")
# um ... willen ohne s:
uw0 <- read_csv("willens/um_willen_DECOW16B_sample.csv")
uw0 <- mutate(uw0, cxn = "willen")
# relevante Spalten finden
mycols <- intersect(colnames(w0), colnames(w0p))
# zusammenfügen
w <- rbind(mutate(select(ws, all_of(mycols)), cxn = "wegens"),
mutate(select(w0, all_of(mycols)), cxn = "wegen"),
mutate(select(w0p, all_of(mycols)), cxn = "wegen"))
# nur true positives behalten
w <- filter(w, keep == "y")
# Duplikate entfernen
w <- w[-which(duplicated(select(w, Left, Key, Right))),]
# nur postnominales wegen(s)
wp <- filter(w, position == "post")
# DATA WRANGLING - um ... willen(s):
uw <- rbind(uws, uw0)
View(w)
filter(w, s_less %in% c("y", "n") & case=="gen" & !is.na(Freq))
# Subset mit starken Maskulina und Neutra
s <- filter(w, s_less %in% c("y", "n") & case=="gen" & !is.na(Freq))
# convert categorical columns to factors
cols <- c("s_less", "cxn", "monoref", "forum", "abbreviation")
s[cols] <- lapply(s[cols], as.factor)
library(ngram)
# Spalte zu NP-Erweiterung hinzufügen
wordcount(w0p$Key[1])
w0$NP_ext
w0$NP_ext %>% table
ws$NP_ext
ws$NP_ext %>% table
grep("lieben", ws$Key)
ws$Key
grep("lieben", uw$Key)
uw[grep("lieben", uw$Key),]
uw[grep("lieben", uw$Key),] %>% View()
# Daten einlesen
# wegens:
ws <- read_csv("wegens/wegens_DECOW16BX_anno.csv")
ws <- mutate(ws, cxn = "wegens")
# wegen ohne s:
w0 <- read_csv("wegens/wegen_sample_DECOW16BX_anno.csv")
w0 <- mutate(w0, cxn = "wegen")
# Nacherhebung postnominales wegen:
w0p <- read_csv("wegens/wegen_postnom_DECOW16A_NANO_filtered.csv")
w0p <- mutate(w0p, cxn = "wegen")
# Spalte Position hinzufügen
w0p$position <- "post"
# um ... willens:
uws <- read_csv("willens/um_willens_DECOW16B.csv")
uws <- mutate(uws, cxn = "willens")
# um ... willen ohne s:
uw0 <- read_csv("willens/um_willen_DECOW16B_sample.csv")
uw0 <- mutate(uw0, cxn = "willen")
# DATA WRANGLING - wegen(s)
# relevante Spalten finden
mycols <- intersect(colnames(w0), colnames(w0p))
# zusammenfügen
w <- rbind(mutate(select(ws, all_of(mycols)), cxn = "wegens"),
mutate(select(w0, all_of(mycols)), cxn = "wegen"),
mutate(select(w0p, all_of(mycols)), cxn = "wegen"))
# nur true positives behalten
w <- filter(w, keep == "y")
# Duplikate entfernen
w <- w[-which(duplicated(select(w, Left, Key, Right))),]
# nur postnominales wegen(s)
wp <- filter(w, position == "post")
# DATA WRANGLING - um ... willen(s):
uw <- rbind(uws, uw0)
# add binary proper name column
s$name <- factor(ifelse(s$Proper_name!="n", "y", "n"))
# willen(s)
s2 <- select(s, s_less, cxn, monoref, name, Freq, pn_or_acro_or_nonnative_in_s, abbreviation, position, Determiner)
# use more intuitive names
colnames(s2) <- c("s_los", "Variante", "Monoreferenz", "Eigenname" "Frequenz", "Schonungsbedarf_s", "Kurzwort", "Position", "Determinierer")
# use more intuitive names
colnames(s2) <- c("s_los", "Variante", "Monoreferenz", "Eigenname", "Frequenz", "Schonungsbedarf_s", "Kurzwort", "Position", "Determinierer")
# replace NAs
s2 <- replace_na(s2, list(Schonungsbedarf_s = "n"))
s2$Schonungsbedarf_s <- factor(s2$Schonungsbedarf_s)
# German s-los column
s2$s_los <- ifelse(s2$s_los=="n", "mit s", "s-los")
s2$s_los <- factor(s2$s_los, levels = rev(c("s-los", "mit s")))
# log frequency
s2$LogFreq <- log(s2$Frequenz)
s2b
# Determiner as factor
s2$Determinierer <- factor(s2$Determinierer)
stree <- ctree(s_los ~ Variante + Monoreferenz +
Eigenname + Kurzwort + Schonungsbedarf_s + LogFreq, data = s2)
plot(stree)
stree <- ctree(s_los ~ Variante + Monoreferenz + Genus +
Eigenname + Kurzwort + Schonungsbedarf_s + LogFreq, data = s2)
# random forest
sforest <- cforest(s_los ~ Variante + Monoreferenz +
Eigenname + Kurzwort + Schonungsbedarf_s + LogFreq, data = s2)
# get index of concordance - code
# adapted from Tagliamonte & Baayen 2012
s2.trp <- treeresponse(sforest)
s2b$PredFOREST <- sapply(s2.trp, FUN = function(v)return(v[2]))
s2$PredFOREST <- sapply(s2.trp, FUN = function(v)return(v[2]))
s2$s_los_bin <- (s2$s_los=="s-los") + 0
somers2(s2$PredFOREST, s2$s_los_bin)
# variable importance
vi <- varimp(sforest)
# variable importance
vi <- varimp(sforest, conditional = T)
vi
lattice::dotplot(vi)
lattice::dotplot(sort(vi))
lattice::dotplot(sort(vi))
# Subset mit starken Maskulina und Neutra
s <- filter(wp, s_less %in% c("y", "n") & case=="gen" & !is.na(Freq))
# convert categorical columns to factors
cols <- c("s_less", "cxn", "monoref", "forum", "abbreviation")
s[cols] <- lapply(s[cols], as.factor)
# add binary proper name column
s$name <- factor(ifelse(s$Proper_name!="n", "y", "n"))
# willen(s)
s2 <- select(s, s_less, cxn, monoref, name, Freq, pn_or_acro_or_nonnative_in_s, abbreviation, position, Determiner)
# use more intuitive names
colnames(s2) <- c("s_los", "Variante", "Monoreferenz", "Eigenname", "Frequenz", "Schonungsbedarf_s", "Kurzwort", "Position", "Determinierer")
# replace NAs
s2 <- replace_na(s2, list(Schonungsbedarf_s = "n"))
s2$Schonungsbedarf_s <- factor(s2$Schonungsbedarf_s)
# German s-los column
s2$s_los <- ifelse(s2$s_los=="n", "mit s", "s-los")
s2$s_los <- factor(s2$s_los, levels = rev(c("s-los", "mit s")))
# log frequency
s2$LogFreq <- log(s2$Frequenz)
# Determiner as factor
s2$Determinierer <- factor(s2$Determinierer)
# ctree
stree <- ctree(s_los ~ Variante + Monoreferenz +
Eigenname + Kurzwort + Schonungsbedarf_s + LogFreq, data = s2)
plot(stree)
# random forest
sforest <- cforest(s_los ~ Variante + Monoreferenz +
Eigenname + Kurzwort + Schonungsbedarf_s + LogFreq, data = s2)
# get index of concordance - code
# adapted from Tagliamonte & Baayen 2012
s2.trp <- treeresponse(sforest)
s2$PredFOREST <- sapply(s2.trp, FUN = function(v)return(v[2]))
s2$s_los_bin <- (s2$s_los=="s-los") + 0
somers2(s2$PredFOREST, s2$s_los_bin)
# variable importance
vi <- varimp(sforest, conditional = T)
lattice::dotplot(sort(vi))
# Subset mit starken Maskulina und Neutra
s <- filter(w, s_less %in% c("y", "n") & case=="gen" & !is.na(Freq))
# convert categorical columns to factors
cols <- c("s_less", "cxn", "monoref", "forum", "abbreviation", "position")
s[cols] <- lapply(s[cols], as.factor)
# add binary proper name column
s$name <- factor(ifelse(s$Proper_name!="n", "y", "n"))
# willen(s)
s2 <- select(s, s_less, cxn, monoref, name, Freq, pn_or_acro_or_nonnative_in_s, abbreviation, position, Determiner)
# use more intuitive names
colnames(s2) <- c("s_los", "Variante", "Monoreferenz", "Eigenname", "Frequenz", "Schonungsbedarf_s", "Kurzwort", "Position", "Determinierer")
# replace NAs
s2 <- replace_na(s2, list(Schonungsbedarf_s = "n"))
s2$Schonungsbedarf_s <- factor(s2$Schonungsbedarf_s)
# German s-los column
s2$s_los <- ifelse(s2$s_los=="n", "mit s", "s-los")
s2$s_los <- factor(s2$s_los, levels = rev(c("s-los", "mit s")))
# log frequency
s2$LogFreq <- log(s2$Frequenz)
# Determiner as factor
s2$Determinierer <- factor(s2$Determinierer)
# ctree
stree <- ctree(s_los ~ Variante + Monoreferenz + Position +
Eigenname + Kurzwort + Schonungsbedarf_s + LogFreq, data = s2)
plot(stree)
# random forest
sforest <- cforest(s_los ~ Variante + Monoreferenz +
Eigenname + Kurzwort + Schonungsbedarf_s + LogFreq, data = s2)
# get index of concordance - code
# adapted from Tagliamonte & Baayen 2012
s2.trp <- treeresponse(sforest)
s2$PredFOREST <- sapply(s2.trp, FUN = function(v)return(v[2]))
s2$s_los_bin <- (s2$s_los=="s-los") + 0
somers2(s2$PredFOREST, s2$s_los_bin)
# variable importance
vi <- varimp(sforest, conditional = T)
lattice::dotplot(sort(vi))
qbarplot(filter(w, keep == "y"), cxn, Case)
w$case
qbarplot(filter(w, keep == "y"), cxn, case)
qbarplot2(filter(w, keep == "y"), cxn, case)
qbarplot2(filter(w, keep == "y"), cxn, case) +
scale_color_viridis_d()
qbarplot2(filter(w, keep == "y"), cxn, case)
p1 <- qbarplot2(filter(w, keep == "y"), cxn, case)
p1 + scale_color_viridis_d()
p1 <- qbarplot2(filter(w, keep == "y"), cxn, case, color = F)
p1 + scale_color_viridis_d()
p1
# Funktion, um schnell Barplots zu erstellen
qbarplot2 <- function(df, ..., color = c("Blues", F), angle = 0) {
if(missing(color)) { color = "Blues"  }
p <- qbarplot(df, cex = 5, ...) + theme_bw() +
theme(axis.text = element_text(size = 18)) +
theme(axis.title = element_text(size = 18)) +
theme(strip.text = element_text(size = 18)) +
theme(legend.text = element_text(size = 18)) +
theme(legend.title = element_text(size = 18, face = "bold")) +
theme(text = element_text(size = 18))
if(angle!=0) {
p <- p + theme(axis.text.y = element_text(size = 18)) +
theme(axis.text.x = element_text(angle = angle, size = 18,hjust = .9))
} else {
if(angle!=0) {
p <- p + theme(axis.text = element_text(size = 18))
}
}
if(color == "Blues") {
p <- p + scale_fill_brewer("Blues")
} else {
p <- p
}
return(p)
}
p1 <- qbarplot2(filter(w, keep == "y"), cxn, case, color = F)
p1
p1 <- qbarplot(filter(w, keep == "y"), cxn, case, color = F)
p1
p1 + scale_color_viridis_d()
p1 <- qbarplot(filter(w, keep == "y"), cxn, case,position, color = F)
p1 + scale_color_viridis_d()
p1 <- qbarplot(filter(w, keep == "y"), cxn, case,position, color = F, wrap100=T)
p1 + scale_color_viridis_d()
p1 + theme_minimal() +scale_color_viridis_d()
p1 + theme_minimal() + scale_color_viridis_d()
?scale_color_viridis_d
p1 + theme_minimal() + scale_color_viridis_d(option = "inferno")
p1 + theme_minimal() + scale_color_viridis_d(option = "magma")
p1 + theme_minimal() + scale_fill_viridis_d(option = "magma")
p1 + scale_fill_viridis_d()
p1 <- qbarplot(filter(w, keep == "y"), cxn, case,position, wrap100 = T)
p1 + scale_fill_viridis_d()
qbarplot(filter(w, keep == "y"), cxn, case,position, wrap100 = T) + scale_fill_viridis_d()
qbarplot(filter(w, keep == "y"), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .1, end = .9)
qbarplot(filter(w, keep == "y"), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .1, end = .7)
qbarplot(filter(w, keep == "y"), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = .9)
w$case
unique(w$case)
unique(w$case) %>% sort
w$case <- factor(w$case, levels = c("nom", "gen", "gen_dat", "gen_dat_nom", "gen_nom_akk", "gen_dat_nom_akk", "gen_akk", "dat_akk", "akk", "dat", "dat_akk", "unclear"))
w$case <- factor(w$case, levels = c("nom", "gen", "gen_dat", "gen_dat_nom", "gen_nom_akk", "gen_dat_nom_akk", "gen_akk", "nom_akk", "akk", "dat", "dat_akk", "unclear"))
qbarplot(filter(w, keep == "y"), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = .9)
qbarplot(filter(w, keep == "y" & position!="both"), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = .9)
w$case %>% table
# nur mit >10 Belegen:
qbarplot(filter(w, keep == "y" & position!="both" & cae %in% c("gen", "gen_dat", "gen_dat_nom_akk", "nom_akk", "dat", "unclear")), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = .9)
# nur mit >10 Belegen:
qbarplot(filter(w, keep == "y" & position!="both" & case %in% c("gen", "gen_dat", "gen_dat_nom_akk", "nom_akk", "dat", "unclear")), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = .9)
?filter
# nur mit >10 Belegen:
qbarplot(filter(w, keep == "y" & position!="both" & case %in% c("gen", "gen_dat", "gen_dat_nom_akk", "nom_akk", "dat", "unclear")), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = .9)
# nur mit >10 Belegen:
qbarplot(filter(w, keep == "y" & position!="both" & case %in% c("gen", "gen_dat", "gen_dat_nom_akk", "nom_akk", "dat", "unclear")), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = .9, drop = TRUE)
# nur mit >10 Belegen:
qbarplot(droplevels(filter(w, keep == "y" & position!="both" & case %in% c("gen", "gen_dat", "gen_dat_nom_akk", "nom_akk", "dat", "unclear"))), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = .9, drop = TRUE)
# nur mit >10 Belegen:
qbarplot(droplevels(filter(w, keep == "y" & position!="both" & case %in% c("gen", "gen_dat", "gen_dat_nom_akk", "nom_akk", "dat", "unclear"))), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = .9)
# nur mit >10 Belegen:
qbarplot(droplevels(filter(w, keep == "y" & position!="both" & case %in% c("gen", "gen_dat", "gen_dat_nom_akk", "nom_akk", "dat", "unclear"))), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = 1)
# nur mit >10 Belegen:
qbarplot(droplevels(filter(w, keep == "y" & position!="both" & case %in% c("gen", "gen_dat", "gen_dat_nom_akk", "nom_akk", "dat", "unclear"))), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = 1) + ylab("Relative Frequenz") + xlab("Konstruktion") +
guides(fill = guide_legend(title = "Kasus"))
Sys.getenv()
Sys.info()
renv::snapshot(lockfile = NULL)
renv::snapshot()
