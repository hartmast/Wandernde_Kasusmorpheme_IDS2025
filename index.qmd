---
title: "Wandernde Kasusmorpheme"
format: html
editor: visual
---

## Wandernde Kasusmorpheme

Dieses Skript dokumentiert die Datenanalyse für eine Nacherhebung von \[ART (ADJ) N *wegen*\]-Konstruktionen für den Beitrag "'Wandernde' Kasusmorpheme: Variation, Fehler oder Vorboten des Sprachwandels?". Die restliche Analyse stützt sich auf zuvor getätigte Analysen, die [hier](https://doi.org/10.17605/OSF.IO/AUMG2) im Detail nachzulesen sind.

## Vorbereitung

Pakete installieren und laden:

```{r}
# CRAN-Pakete installieren
sapply(c("data.table", "tidyverse", "devtools", "party", "Hmisc", "rms", "RColorBrewer", "readxl", "patchwork"), function(x) 
  if(!is.element(x, installed.packages())) install.packages(x, dependencies = T))

# Nom-CRAN-Paket installieren (falls noch nicht installiert)
if(!is.element("wizard", installed.packages())) {
  devtools::install_github("hartmast/wizard")
}

# Pakete laden
library(tidyverse)
library(data.table)
library(wizard)
library(party)
library(Hmisc)
library(rms)
library(RColorBrewer)
library(readxl)
library(patchwork)
library(ngram)

# Funktion, um schnell Barplots zu erstellen
qbarplot2 <- function(df, ..., color = c("Blues", F), angle = 0) {
  
  if(missing(color)) { color = "Blues"  }
  
  p <- qbarplot(df, cex = 5, ...) + theme_bw() +
    theme(axis.text = element_text(size = 18)) +
    theme(axis.title = element_text(size = 18)) +
    theme(strip.text = element_text(size = 18)) +
    theme(legend.text = element_text(size = 18)) +
    theme(legend.title = element_text(size = 18, face = "bold")) +
    theme(text = element_text(size = 18))
  
  if(angle!=0) {
    p <- p + theme(axis.text.y = element_text(size = 18)) +
      theme(axis.text.x = element_text(angle = angle, size = 18,hjust = .9))
  } else {
    if(angle!=0) {
     p <- p + theme(axis.text = element_text(size = 18))
    }
  }
  
  
  if(color == "Blues") {
    p <- p + scale_fill_brewer("Blues")
  } else {
    p <- p
  }
  
  return(p)
    
}
```

## Daten einlesen & Data Wrangling

Hier werden die Daten eingelesen und die zusammengehörigen Datensätze miteinander verknüpft.

```{r}

# Daten einlesen

# wegens:
ws <- read_csv("wegens/wegens_DECOW16BX_anno.csv")
ws <- mutate(ws, cxn = "wegens")

# wegen ohne s:
w0 <- read_csv("wegens/wegen_sample_DECOW16BX_anno.csv")
w0 <- mutate(w0, cxn = "wegen")

# Nacherhebung postnominales wegen:
w0p <- read_csv("wegens/wegen_postnom_DECOW16A_NANO_filtered.csv")
w0p <- mutate(w0p, cxn = "wegen")

# Spalte Position hinzufügen
w0p$position <- "post"


# DATA WRANGLING - wegen(s)

# relevante Spalten finden
mycols <- intersect(colnames(w0), colnames(w0p))

# zusammenfügen
w <- rbind(mutate(select(ws, all_of(mycols)), cxn = "wegens"),
mutate(select(w0, all_of(mycols)), cxn = "wegen"),
mutate(select(w0p, all_of(mycols)), cxn = "wegen"))

# nur true positives behalten
w <- filter(w, keep == "y")

# Duplikate entfernen
w <- w[-which(duplicated(select(w, Left, Key, Right))),]

# nur postnominales wegen(s)
wp <- filter(w, position == "post")


```

## Random forest - postnom. wegen(s)

```{r}

# Subset mit starken Maskulina und Neutra
s <- filter(wp, s_less %in% c("y", "n") & case=="gen" & !is.na(Freq))

# convert categorical columns to factors
cols <- c("s_less", "cxn", "monoref", "forum", "abbreviation")
s[cols] <- lapply(s[cols], as.factor)

# add binary proper name column
s$name <- factor(ifelse(s$Proper_name!="n", "y", "n"))

# willen(s)
s2 <- select(s, s_less, cxn, monoref, name, Freq, pn_or_acro_or_nonnative_in_s, abbreviation, position, Determiner)

# use more intuitive names
colnames(s2) <- c("s_los", "Variante", "Monoreferenz", "Eigenname", "Frequenz", "Schonungsbedarf_s", "Kurzwort", "Position", "Determinierer")

# replace NAs
s2 <- replace_na(s2, list(Schonungsbedarf_s = "n"))
s2$Schonungsbedarf_s <- factor(s2$Schonungsbedarf_s)

# German s-los column
s2$s_los <- ifelse(s2$s_los=="n", "mit s", "s-los")
s2$s_los <- factor(s2$s_los, levels = rev(c("s-los", "mit s")))

# log frequency
s2$LogFreq <- log(s2$Frequenz)

# Determiner as factor
s2$Determinierer <- factor(s2$Determinierer)


# ctree
stree <- ctree(s_los ~ Variante + Monoreferenz +   
                 Eigenname + Kurzwort + Schonungsbedarf_s + LogFreq, data = s2)

plot(stree)


# random forest
sforest <- cforest(s_los ~ Variante + Monoreferenz +   
                 Eigenname + Kurzwort + Schonungsbedarf_s + LogFreq, data = s2)

# get index of concordance - code
# adapted from Tagliamonte & Baayen 2012
s2.trp <- treeresponse(sforest)
s2$PredFOREST <- sapply(s2.trp, FUN = function(v)return(v[2]))
s2$s_los_bin <- (s2$s_los=="s-los") + 0
somers2(s2$PredFOREST, s2$s_los_bin)

# variable importance
vi <- varimp(sforest, conditional = T)
lattice::dotplot(sort(vi))


```

## Random forest - wegen(s) prä- und postnom.

```{r}

# Subset mit starken Maskulina und Neutra
s <- filter(w, s_less %in% c("y", "n") & case=="gen" & !is.na(Freq))

# convert categorical columns to factors
cols <- c("s_less", "cxn", "monoref", "forum", "abbreviation", "position")
s[cols] <- lapply(s[cols], as.factor)

# add binary proper name column
s$name <- factor(ifelse(s$Proper_name!="n", "y", "n"))

# willen(s)
s2 <- select(s, s_less, cxn, monoref, name, Freq, pn_or_acro_or_nonnative_in_s, abbreviation, position, Determiner)

# use more intuitive names
colnames(s2) <- c("s_los", "Variante", "Monoreferenz", "Eigenname", "Frequenz", "Schonungsbedarf_s", "Kurzwort", "Position", "Determinierer")

# replace NAs
s2 <- replace_na(s2, list(Schonungsbedarf_s = "n"))
s2$Schonungsbedarf_s <- factor(s2$Schonungsbedarf_s)

# German s-los column
s2$s_los <- ifelse(s2$s_los=="n", "mit s", "s-los")
s2$s_los <- factor(s2$s_los, levels = rev(c("s-los", "mit s")))

# log frequency
s2$LogFreq <- log(s2$Frequenz)

# Determiner as factor
s2$Determinierer <- factor(s2$Determinierer)


# ctree
stree <- ctree(s_los ~ Variante + Monoreferenz + Position +   
                 Eigenname + Kurzwort + Schonungsbedarf_s + LogFreq, data = s2)

plot(stree)


# random forest
sforest <- cforest(s_los ~ Variante + Monoreferenz +   
                 Eigenname + Kurzwort + Schonungsbedarf_s + LogFreq, data = s2)

# get index of concordance - code
# adapted from Tagliamonte & Baayen 2012
s2.trp <- treeresponse(sforest)
s2$PredFOREST <- sapply(s2.trp, FUN = function(v)return(v[2]))
s2$s_los_bin <- (s2$s_los=="s-los") + 0
somers2(s2$PredFOREST, s2$s_los_bin)

# variable importance
vi <- varimp(sforest, conditional = T)
lattice::dotplot(sort(vi))


```

## Kasusverteilung

```{r}

w$case <- factor(w$case, levels = c("nom", "gen", "gen_dat", "gen_dat_nom", "gen_nom_akk", "gen_dat_nom_akk", "gen_akk", "nom_akk", "akk", "dat", "dat_akk", "unclear"))

# alle Kasus:
qbarplot(filter(w, keep == "y" & position!="both"), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = .9)

# nur Kasuskategorien mit >10 Belegen:
qbarplot(droplevels(filter(w, keep == "y" & position!="both" & case %in% c("gen", "gen_dat", "gen_dat_nom_akk", "nom_akk", "dat", "unclear"))), cxn, case,position, wrap100 = T) + scale_fill_viridis_d(begin = .3, end = 1) + ylab("Relative Frequenz") + xlab("Konstruktion") +
  guides(fill = guide_legend(title = "Kasus"))





```

## Systemumgebung

Systeminfo und Paketversionen zur besseren Reproduzierbarkeit

```{r, message=FALSE}
Sys.info()
renv::snapshot()
```
